{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar packstream_1 = require(\"../packstream\");\n\nvar transformer_1 = require(\"./transformer\");\n\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * Creates the Node Transformer\n * @returns {TypeTransformer}\n */\n\nfunction createNodeTransformer() {\n  return new transformer_1.TypeTransformer({\n    signature: NODE,\n    isTypeInstance: function (object) {\n      return object instanceof neo4j_driver_core_1.Node;\n    },\n    toStructure: function (object) {\n      throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass nodes in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n    },\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('Node', NODE_STRUCT_SIZE, struct.size);\n\n      var _a = __read(struct.fields, 3),\n          identity = _a[0],\n          labels = _a[1],\n          properties = _a[2];\n\n      return new neo4j_driver_core_1.Node(identity, labels, properties);\n    }\n  });\n}\n/**\n * Creates the Relationship Transformer\n * @returns {TypeTransformer}\n */\n\n\nfunction createRelationshipTransformer() {\n  return new transformer_1.TypeTransformer({\n    signature: RELATIONSHIP,\n    isTypeInstance: function (object) {\n      return object instanceof neo4j_driver_core_1.Relationship;\n    },\n    toStructure: function (object) {\n      throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass relationships in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n    },\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, struct.size);\n\n      var _a = __read(struct.fields, 5),\n          identity = _a[0],\n          startNodeIdentity = _a[1],\n          endNodeIdentity = _a[2],\n          type = _a[3],\n          properties = _a[4];\n\n      return new neo4j_driver_core_1.Relationship(identity, startNodeIdentity, endNodeIdentity, type, properties);\n    }\n  });\n}\n/**\n * Creates the Unbound Relationship Transformer\n * @returns {TypeTransformer}\n */\n\n\nfunction createUnboundRelationshipTransformer() {\n  return new transformer_1.TypeTransformer({\n    signature: UNBOUND_RELATIONSHIP,\n    isTypeInstance: function (object) {\n      return object instanceof neo4j_driver_core_1.UnboundRelationship;\n    },\n    toStructure: function (object) {\n      throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass unbound relationships in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n    },\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, struct.size);\n\n      var _a = __read(struct.fields, 3),\n          identity = _a[0],\n          type = _a[1],\n          properties = _a[2];\n\n      return new neo4j_driver_core_1.UnboundRelationship(identity, type, properties);\n    }\n  });\n}\n/**\n * Creates the Path Transformer\n * @returns {TypeTransformer}\n */\n\n\nfunction createPathTransformer() {\n  return new transformer_1.TypeTransformer({\n    signature: PATH,\n    isTypeInstance: function (object) {\n      return object instanceof neo4j_driver_core_1.Path;\n    },\n    toStructure: function (object) {\n      throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass paths in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n    },\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('Path', PATH_STRUCT_SIZE, struct.size);\n\n      var _a = __read(struct.fields, 3),\n          nodes = _a[0],\n          rels = _a[1],\n          sequence = _a[2];\n\n      var segments = [];\n      var prevNode = nodes[0];\n\n      for (var i = 0; i < sequence.length; i += 2) {\n        var nextNode = nodes[sequence[i + 1]];\n        var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n        var rel = void 0;\n\n        if (relIndex > 0) {\n          rel = rels[relIndex - 1];\n\n          if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n            // To avoid duplication, relationships in a path do not contain\n            // information about their start and end nodes, that's instead\n            // inferred from the path sequence. This is us inferring (and,\n            // for performance reasons remembering) the start/end of a rel.\n            rels[relIndex - 1] = rel = rel.bindTo(prevNode, nextNode);\n          }\n        } else {\n          rel = rels[-relIndex - 1];\n\n          if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n            // See above\n            rels[-relIndex - 1] = rel = rel.bindTo(nextNode, prevNode);\n          }\n        } // Done hydrating one path segment.\n\n\n        segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n        prevNode = nextNode;\n      }\n\n      return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n    }\n  });\n}\n\nexports.default = {\n  createNodeTransformer: createNodeTransformer,\n  createRelationshipTransformer: createRelationshipTransformer,\n  createUnboundRelationshipTransformer: createUnboundRelationshipTransformer,\n  createPathTransformer: createPathTransformer\n};","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","Object","defineProperty","exports","neo4j_driver_core_1","require","packstream_1","transformer_1","PROTOCOL_ERROR","NODE","NODE_STRUCT_SIZE","RELATIONSHIP","RELATIONSHIP_STRUCT_SIZE","UNBOUND_RELATIONSHIP","UNBOUND_RELATIONSHIP_STRUCT_SIZE","PATH","PATH_STRUCT_SIZE","createNodeTransformer","TypeTransformer","signature","isTypeInstance","object","Node","toStructure","newError","concat","fromStructure","struct","structure","verifyStructSize","size","_a","fields","identity","labels","properties","createRelationshipTransformer","Relationship","startNodeIdentity","endNodeIdentity","type","createUnboundRelationshipTransformer","UnboundRelationship","createPathTransformer","Path","nodes","rels","sequence","segments","prevNode","length","nextNode","relIndex","toNumber","rel","bindTo","PathSegment","default"],"sources":["C:/projects/levelUp_v1/Level-Up-FN/Level-Up-Fronten-master/node_modules/neo4j-driver-bolt-connection/lib/bolt/bolt-protocol-v1.transformer.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar packstream_1 = require(\"../packstream\");\nvar transformer_1 = require(\"./transformer\");\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * Creates the Node Transformer\n * @returns {TypeTransformer}\n */\nfunction createNodeTransformer() {\n    return new transformer_1.TypeTransformer({\n        signature: NODE,\n        isTypeInstance: function (object) { return object instanceof neo4j_driver_core_1.Node; },\n        toStructure: function (object) {\n            throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass nodes in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n        },\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('Node', NODE_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), identity = _a[0], labels = _a[1], properties = _a[2];\n            return new neo4j_driver_core_1.Node(identity, labels, properties);\n        }\n    });\n}\n/**\n * Creates the Relationship Transformer\n * @returns {TypeTransformer}\n */\nfunction createRelationshipTransformer() {\n    return new transformer_1.TypeTransformer({\n        signature: RELATIONSHIP,\n        isTypeInstance: function (object) { return object instanceof neo4j_driver_core_1.Relationship; },\n        toStructure: function (object) {\n            throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass relationships in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n        },\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 5), identity = _a[0], startNodeIdentity = _a[1], endNodeIdentity = _a[2], type = _a[3], properties = _a[4];\n            return new neo4j_driver_core_1.Relationship(identity, startNodeIdentity, endNodeIdentity, type, properties);\n        }\n    });\n}\n/**\n * Creates the Unbound Relationship Transformer\n * @returns {TypeTransformer}\n */\nfunction createUnboundRelationshipTransformer() {\n    return new transformer_1.TypeTransformer({\n        signature: UNBOUND_RELATIONSHIP,\n        isTypeInstance: function (object) { return object instanceof neo4j_driver_core_1.UnboundRelationship; },\n        toStructure: function (object) {\n            throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass unbound relationships in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n        },\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), identity = _a[0], type = _a[1], properties = _a[2];\n            return new neo4j_driver_core_1.UnboundRelationship(identity, type, properties);\n        }\n    });\n}\n/**\n * Creates the Path Transformer\n * @returns {TypeTransformer}\n */\nfunction createPathTransformer() {\n    return new transformer_1.TypeTransformer({\n        signature: PATH,\n        isTypeInstance: function (object) { return object instanceof neo4j_driver_core_1.Path; },\n        toStructure: function (object) {\n            throw (0, neo4j_driver_core_1.newError)(\"It is not allowed to pass paths in query parameters, given: \".concat(object), PROTOCOL_ERROR);\n        },\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('Path', PATH_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), nodes = _a[0], rels = _a[1], sequence = _a[2];\n            var segments = [];\n            var prevNode = nodes[0];\n            for (var i = 0; i < sequence.length; i += 2) {\n                var nextNode = nodes[sequence[i + 1]];\n                var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n                var rel = void 0;\n                if (relIndex > 0) {\n                    rel = rels[relIndex - 1];\n                    if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                        // To avoid duplication, relationships in a path do not contain\n                        // information about their start and end nodes, that's instead\n                        // inferred from the path sequence. This is us inferring (and,\n                        // for performance reasons remembering) the start/end of a rel.\n                        rels[relIndex - 1] = rel = rel.bindTo(prevNode, nextNode);\n                    }\n                }\n                else {\n                    rel = rels[-relIndex - 1];\n                    if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                        // See above\n                        rels[-relIndex - 1] = rel = rel.bindTo(nextNode, prevNode);\n                    }\n                }\n                // Done hydrating one path segment.\n                segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n                prevNode = nextNode;\n            }\n            return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n        }\n    });\n}\nexports.default = {\n    createNodeTransformer: createNodeTransformer,\n    createRelationshipTransformer: createRelationshipTransformer,\n    createUnboundRelationshipTransformer: createUnboundRelationshipTransformer,\n    createPathTransformer: createPathTransformer\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}