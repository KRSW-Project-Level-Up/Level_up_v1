{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar packstream_1 = require(\"../packstream\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar bolt_protocol_v4x4_transformer_1 = __importDefault(require(\"./bolt-protocol-v4x4.transformer\"));\n\nvar temporal_factory_1 = require(\"./temporal-factory\");\n\nvar functional_1 = require(\"../lang/functional\");\n\nvar localDateTimeToEpochSecond = neo4j_driver_core_1.internal.temporalUtil.localDateTimeToEpochSecond;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x49;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x69;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n\nfunction createDateTimeWithZoneIdTransformer(config, logger) {\n  var disableLosslessIntegers = config.disableLosslessIntegers,\n      useBigInt = config.useBigInt;\n  var dateTimeWithZoneIdTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithZoneIdTransformer(config);\n  return dateTimeWithZoneIdTransformer.extendsWith({\n    signature: DATE_TIME_WITH_ZONE_ID,\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, struct.size);\n\n      var _a = __read(struct.fields, 3),\n          epochSecond = _a[0],\n          nano = _a[1],\n          timeZoneId = _a[2];\n\n      var localDateTime = getTimeInZoneId(timeZoneId, epochSecond, nano);\n      var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, (0, neo4j_driver_core_1.int)(nano), localDateTime.timeZoneOffsetSeconds, timeZoneId);\n      return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n    },\n    toStructure: function (value) {\n      var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n      var offset = value.timeZoneOffsetSeconds != null ? value.timeZoneOffsetSeconds : getOffsetFromZoneId(value.timeZoneId, epochSecond, value.nanosecond);\n\n      if (value.timeZoneOffsetSeconds == null) {\n        logger.warn('DateTime objects without \"timeZoneOffsetSeconds\" property ' + 'are prune to bugs related to ambiguous times. For instance, ' + '2022-10-30T2:30:00[Europe/Berlin] could be GMT+1 or GMT+2.');\n      }\n\n      var utc = epochSecond.subtract(offset);\n      var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n      var timeZoneId = value.timeZoneId;\n      return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_ID, [utc, nano, timeZoneId]);\n    }\n  });\n}\n/**\n * Returns the offset for a given timezone id\n *\n * Javascript doesn't have support for direct getting the timezone offset from a given\n * TimeZoneId and DateTime in the given TimeZoneId. For solving this issue,\n *\n * 1. The ZoneId is applied to the timestamp, so we could make the difference between the\n * given timestamp and the new calculated one. This is the offset for the timezone\n * in the utc is equal to epoch (some time in the future or past)\n * 2. The offset is subtracted from the timestamp, so we have an estimated utc timestamp.\n * 3. The ZoneId is applied to the new timestamp, se we could could make the difference\n * between the new timestamp and the calculated one. This is the offset for the given timezone.\n *\n * Example:\n *    Input: 2022-3-27 1:59:59 'Europe/Berlin'\n *    Apply 1, 2022-3-27 1:59:59 => 2022-3-27 3:59:59 'Europe/Berlin' +2:00\n *    Apply 2, 2022-3-27 1:59:59 - 2:00 => 2022-3-26 23:59:59\n *    Apply 3, 2022-3-26 23:59:59 => 2022-3-27 00:59:59 'Europe/Berlin' +1:00\n *  The offset is +1 hour.\n *\n * @param {string} timeZoneId The timezone id\n * @param {Integer} epochSecond The epoch second in the timezone id\n * @param {Integerable} nanosecond The nanoseconds in the timezone id\n * @returns The timezone offset\n */\n\n\nfunction getOffsetFromZoneId(timeZoneId, epochSecond, nanosecond) {\n  var dateTimeWithZoneAppliedTwice = getTimeInZoneId(timeZoneId, epochSecond, nanosecond); // The wallclock form the current date time\n\n  var epochWithZoneAppliedTwice = localDateTimeToEpochSecond(dateTimeWithZoneAppliedTwice.year, dateTimeWithZoneAppliedTwice.month, dateTimeWithZoneAppliedTwice.day, dateTimeWithZoneAppliedTwice.hour, dateTimeWithZoneAppliedTwice.minute, dateTimeWithZoneAppliedTwice.second, nanosecond);\n  var offsetOfZoneInTheFutureUtc = epochWithZoneAppliedTwice.subtract(epochSecond);\n  var guessedUtc = epochSecond.subtract(offsetOfZoneInTheFutureUtc);\n  var zonedDateTimeFromGuessedUtc = getTimeInZoneId(timeZoneId, guessedUtc, nanosecond);\n  var zonedEpochFromGuessedUtc = localDateTimeToEpochSecond(zonedDateTimeFromGuessedUtc.year, zonedDateTimeFromGuessedUtc.month, zonedDateTimeFromGuessedUtc.day, zonedDateTimeFromGuessedUtc.hour, zonedDateTimeFromGuessedUtc.minute, zonedDateTimeFromGuessedUtc.second, nanosecond);\n  var offset = zonedEpochFromGuessedUtc.subtract(guessedUtc);\n  return offset;\n}\n\nfunction getTimeInZoneId(timeZoneId, epochSecond, nano) {\n  var formatter = new Intl.DateTimeFormat('en-US', {\n    timeZone: timeZoneId,\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n    second: 'numeric',\n    hour12: false,\n    era: 'narrow'\n  });\n  var utc = (0, neo4j_driver_core_1.int)(epochSecond).multiply(1000).add((0, neo4j_driver_core_1.int)(nano).div(1000000)).toNumber();\n  var formattedUtcParts = formatter.formatToParts(utc);\n  var localDateTime = formattedUtcParts.reduce(function (obj, currentValue) {\n    if (currentValue.type === 'era') {\n      obj.adjustEra = currentValue.value.toUpperCase() === 'B' ? function (year) {\n        return year.subtract(1).negate();\n      } // 1BC equals to year 0 in astronomical year numbering\n      : functional_1.identity;\n    } else if (currentValue.type === 'hour') {\n      obj.hour = (0, neo4j_driver_core_1.int)(currentValue.value).modulo(24);\n    } else if (currentValue.type !== 'literal') {\n      obj[currentValue.type] = (0, neo4j_driver_core_1.int)(currentValue.value);\n    }\n\n    return obj;\n  }, {});\n  localDateTime.year = localDateTime.adjustEra(localDateTime.year);\n  var epochInTimeZone = localDateTimeToEpochSecond(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond);\n  localDateTime.timeZoneOffsetSeconds = epochInTimeZone.subtract(epochSecond);\n  localDateTime.hour = localDateTime.hour.modulo(24);\n  return localDateTime;\n}\n\nfunction createDateTimeWithOffsetTransformer(config) {\n  var disableLosslessIntegers = config.disableLosslessIntegers,\n      useBigInt = config.useBigInt;\n  var dateTimeWithOffsetTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithOffsetTransformer(config);\n  return dateTimeWithOffsetTransformer.extendsWith({\n    signature: DATE_TIME_WITH_ZONE_OFFSET,\n    toStructure: function (value) {\n      var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n      var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n      var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n      var utcSecond = epochSecond.subtract(timeZoneOffsetSeconds);\n      return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_OFFSET, [utcSecond, nano, timeZoneOffsetSeconds]);\n    },\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, struct.size);\n\n      var _a = __read(struct.fields, 3),\n          utcSecond = _a[0],\n          nano = _a[1],\n          timeZoneOffsetSeconds = _a[2];\n\n      var epochSecond = (0, neo4j_driver_core_1.int)(utcSecond).add(timeZoneOffsetSeconds);\n      var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n      var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n      return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n    }\n  });\n}\n\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n\n  var convert = function (value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n\n  var clone = Object.create(Object.getPrototypeOf(obj));\n\n  for (var prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n\n  Object.freeze(clone);\n  return clone;\n}\n\nexports.default = {\n  createDateTimeWithZoneIdTransformer: createDateTimeWithZoneIdTransformer,\n  createDateTimeWithOffsetTransformer: createDateTimeWithOffsetTransformer\n};","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__importDefault","mod","__esModule","Object","defineProperty","exports","packstream_1","require","neo4j_driver_core_1","bolt_protocol_v4x4_transformer_1","temporal_factory_1","functional_1","localDateTimeToEpochSecond","internal","temporalUtil","DATE_TIME_WITH_ZONE_OFFSET","DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE","DATE_TIME_WITH_ZONE_ID","DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE","createDateTimeWithZoneIdTransformer","config","logger","disableLosslessIntegers","useBigInt","dateTimeWithZoneIdTransformer","default","extendsWith","signature","fromStructure","struct","structure","verifyStructSize","size","_a","fields","epochSecond","nano","timeZoneId","localDateTime","getTimeInZoneId","result","DateTime","year","month","day","hour","minute","second","int","timeZoneOffsetSeconds","convertIntegerPropsIfNeeded","toStructure","nanosecond","offset","getOffsetFromZoneId","warn","utc","subtract","Structure","dateTimeWithZoneAppliedTwice","epochWithZoneAppliedTwice","offsetOfZoneInTheFutureUtc","guessedUtc","zonedDateTimeFromGuessedUtc","zonedEpochFromGuessedUtc","formatter","Intl","DateTimeFormat","timeZone","hour12","era","multiply","add","div","toNumber","formattedUtcParts","formatToParts","reduce","obj","currentValue","type","adjustEra","toUpperCase","negate","identity","modulo","epochInTimeZone","createDateTimeWithOffsetTransformer","dateTimeWithOffsetTransformer","utcSecond","epochSecondAndNanoToLocalDateTime","convert","toBigInt","toNumberOrInfinity","clone","create","getPrototypeOf","prop","prototype","hasOwnProperty","isInt","freeze"],"sources":["C:/projects/levelUp_v1/Level-Up-FN/Level-Up-Fronten-master/node_modules/neo4j-driver-bolt-connection/lib/bolt/bolt-protocol-v5x0.utc.transformer.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar packstream_1 = require(\"../packstream\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar bolt_protocol_v4x4_transformer_1 = __importDefault(require(\"./bolt-protocol-v4x4.transformer\"));\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar functional_1 = require(\"../lang/functional\");\nvar localDateTimeToEpochSecond = neo4j_driver_core_1.internal.temporalUtil.localDateTimeToEpochSecond;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x49;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x69;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nfunction createDateTimeWithZoneIdTransformer(config, logger) {\n    var disableLosslessIntegers = config.disableLosslessIntegers, useBigInt = config.useBigInt;\n    var dateTimeWithZoneIdTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithZoneIdTransformer(config);\n    return dateTimeWithZoneIdTransformer.extendsWith({\n        signature: DATE_TIME_WITH_ZONE_ID,\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), epochSecond = _a[0], nano = _a[1], timeZoneId = _a[2];\n            var localDateTime = getTimeInZoneId(timeZoneId, epochSecond, nano);\n            var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, (0, neo4j_driver_core_1.int)(nano), localDateTime.timeZoneOffsetSeconds, timeZoneId);\n            return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n        },\n        toStructure: function (value) {\n            var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n            var offset = value.timeZoneOffsetSeconds != null\n                ? value.timeZoneOffsetSeconds\n                : getOffsetFromZoneId(value.timeZoneId, epochSecond, value.nanosecond);\n            if (value.timeZoneOffsetSeconds == null) {\n                logger.warn('DateTime objects without \"timeZoneOffsetSeconds\" property ' +\n                    'are prune to bugs related to ambiguous times. For instance, ' +\n                    '2022-10-30T2:30:00[Europe/Berlin] could be GMT+1 or GMT+2.');\n            }\n            var utc = epochSecond.subtract(offset);\n            var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n            var timeZoneId = value.timeZoneId;\n            return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_ID, [utc, nano, timeZoneId]);\n        }\n    });\n}\n/**\n * Returns the offset for a given timezone id\n *\n * Javascript doesn't have support for direct getting the timezone offset from a given\n * TimeZoneId and DateTime in the given TimeZoneId. For solving this issue,\n *\n * 1. The ZoneId is applied to the timestamp, so we could make the difference between the\n * given timestamp and the new calculated one. This is the offset for the timezone\n * in the utc is equal to epoch (some time in the future or past)\n * 2. The offset is subtracted from the timestamp, so we have an estimated utc timestamp.\n * 3. The ZoneId is applied to the new timestamp, se we could could make the difference\n * between the new timestamp and the calculated one. This is the offset for the given timezone.\n *\n * Example:\n *    Input: 2022-3-27 1:59:59 'Europe/Berlin'\n *    Apply 1, 2022-3-27 1:59:59 => 2022-3-27 3:59:59 'Europe/Berlin' +2:00\n *    Apply 2, 2022-3-27 1:59:59 - 2:00 => 2022-3-26 23:59:59\n *    Apply 3, 2022-3-26 23:59:59 => 2022-3-27 00:59:59 'Europe/Berlin' +1:00\n *  The offset is +1 hour.\n *\n * @param {string} timeZoneId The timezone id\n * @param {Integer} epochSecond The epoch second in the timezone id\n * @param {Integerable} nanosecond The nanoseconds in the timezone id\n * @returns The timezone offset\n */\nfunction getOffsetFromZoneId(timeZoneId, epochSecond, nanosecond) {\n    var dateTimeWithZoneAppliedTwice = getTimeInZoneId(timeZoneId, epochSecond, nanosecond);\n    // The wallclock form the current date time\n    var epochWithZoneAppliedTwice = localDateTimeToEpochSecond(dateTimeWithZoneAppliedTwice.year, dateTimeWithZoneAppliedTwice.month, dateTimeWithZoneAppliedTwice.day, dateTimeWithZoneAppliedTwice.hour, dateTimeWithZoneAppliedTwice.minute, dateTimeWithZoneAppliedTwice.second, nanosecond);\n    var offsetOfZoneInTheFutureUtc = epochWithZoneAppliedTwice.subtract(epochSecond);\n    var guessedUtc = epochSecond.subtract(offsetOfZoneInTheFutureUtc);\n    var zonedDateTimeFromGuessedUtc = getTimeInZoneId(timeZoneId, guessedUtc, nanosecond);\n    var zonedEpochFromGuessedUtc = localDateTimeToEpochSecond(zonedDateTimeFromGuessedUtc.year, zonedDateTimeFromGuessedUtc.month, zonedDateTimeFromGuessedUtc.day, zonedDateTimeFromGuessedUtc.hour, zonedDateTimeFromGuessedUtc.minute, zonedDateTimeFromGuessedUtc.second, nanosecond);\n    var offset = zonedEpochFromGuessedUtc.subtract(guessedUtc);\n    return offset;\n}\nfunction getTimeInZoneId(timeZoneId, epochSecond, nano) {\n    var formatter = new Intl.DateTimeFormat('en-US', {\n        timeZone: timeZoneId,\n        year: 'numeric',\n        month: 'numeric',\n        day: 'numeric',\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric',\n        hour12: false,\n        era: 'narrow'\n    });\n    var utc = (0, neo4j_driver_core_1.int)(epochSecond)\n        .multiply(1000)\n        .add((0, neo4j_driver_core_1.int)(nano).div(1000000))\n        .toNumber();\n    var formattedUtcParts = formatter.formatToParts(utc);\n    var localDateTime = formattedUtcParts.reduce(function (obj, currentValue) {\n        if (currentValue.type === 'era') {\n            obj.adjustEra =\n                currentValue.value.toUpperCase() === 'B'\n                    ? function (year) { return year.subtract(1).negate(); } // 1BC equals to year 0 in astronomical year numbering\n                    : functional_1.identity;\n        }\n        else if (currentValue.type === 'hour') {\n            obj.hour = (0, neo4j_driver_core_1.int)(currentValue.value).modulo(24);\n        }\n        else if (currentValue.type !== 'literal') {\n            obj[currentValue.type] = (0, neo4j_driver_core_1.int)(currentValue.value);\n        }\n        return obj;\n    }, {});\n    localDateTime.year = localDateTime.adjustEra(localDateTime.year);\n    var epochInTimeZone = localDateTimeToEpochSecond(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond);\n    localDateTime.timeZoneOffsetSeconds = epochInTimeZone.subtract(epochSecond);\n    localDateTime.hour = localDateTime.hour.modulo(24);\n    return localDateTime;\n}\nfunction createDateTimeWithOffsetTransformer(config) {\n    var disableLosslessIntegers = config.disableLosslessIntegers, useBigInt = config.useBigInt;\n    var dateTimeWithOffsetTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithOffsetTransformer(config);\n    return dateTimeWithOffsetTransformer.extendsWith({\n        signature: DATE_TIME_WITH_ZONE_OFFSET,\n        toStructure: function (value) {\n            var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n            var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n            var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n            var utcSecond = epochSecond.subtract(timeZoneOffsetSeconds);\n            return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_OFFSET, [utcSecond, nano, timeZoneOffsetSeconds]);\n        },\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), utcSecond = _a[0], nano = _a[1], timeZoneOffsetSeconds = _a[2];\n            var epochSecond = (0, neo4j_driver_core_1.int)(utcSecond).add(timeZoneOffsetSeconds);\n            var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n            var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n            return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n        }\n    });\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n    if (!disableLosslessIntegers && !useBigInt) {\n        return obj;\n    }\n    var convert = function (value) {\n        return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n    };\n    var clone = Object.create(Object.getPrototypeOf(obj));\n    for (var prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {\n            var value = obj[prop];\n            clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n        }\n    }\n    Object.freeze(clone);\n    return clone;\n}\nexports.default = {\n    createDateTimeWithZoneIdTransformer: createDateTimeWithZoneIdTransformer,\n    createDateTimeWithOffsetTransformer: createDateTimeWithOffsetTransformer\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}