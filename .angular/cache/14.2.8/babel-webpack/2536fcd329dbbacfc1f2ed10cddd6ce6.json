{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* eslint-disable @typescript-eslint/promise-function-async */\n\nvar observers_1 = require(\"./internal/observers\");\n\nvar util_1 = require(\"./internal/util\");\n\nvar constants_1 = require(\"./internal/constants\");\n\nvar error_1 = require(\"./error\");\n\nvar result_1 = __importDefault(require(\"./result\"));\n\nvar connection_holder_1 = require(\"./internal/connection-holder\");\n\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\n\nvar bookmarks_1 = require(\"./internal/bookmarks\");\n\nvar tx_config_1 = require(\"./internal/tx-config\");\n\nvar transaction_promise_1 = __importDefault(require(\"./transaction-promise\"));\n\nvar transaction_managed_1 = __importDefault(require(\"./transaction-managed\"));\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\n\n\nvar Session =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Object} args\n   * @param {string} args.mode the default access mode for this session.\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n   * @param {Bookmarks} args.bookmarks - The initial bookmarks for this session.\n   * @param {string} args.database the database name\n   * @param {Object} args.config={} - This driver configuration.\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n   * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n   * @param {AuthToken} args.auth - the target auth for the to-be-acquired connection\n   * @param {NotificationFilter} args.notificationFilter - The notification filter used for this session.\n   */\n  function Session(_a) {\n    var mode = _a.mode,\n        connectionProvider = _a.connectionProvider,\n        bookmarks = _a.bookmarks,\n        database = _a.database,\n        config = _a.config,\n        reactive = _a.reactive,\n        fetchSize = _a.fetchSize,\n        impersonatedUser = _a.impersonatedUser,\n        bookmarkManager = _a.bookmarkManager,\n        notificationFilter = _a.notificationFilter,\n        auth = _a.auth,\n        log = _a.log;\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\n    this._getConnectionAcquistionBookmarks = this._getConnectionAcquistionBookmarks.bind(this);\n    this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_READ,\n      auth: auth,\n      database: database,\n      bookmarks: bookmarks,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved,\n      getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n      log: log\n    });\n    this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_WRITE,\n      auth: auth,\n      database: database,\n      bookmarks: bookmarks,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved,\n      getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n      log: log\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._impersonatedUser = impersonatedUser;\n    this._lastBookmarks = bookmarks !== null && bookmarks !== void 0 ? bookmarks : bookmarks_1.Bookmarks.empty();\n    this._configuredBookmarks = this._lastBookmarks;\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._databaseNameResolved = this._database !== '';\n\n    var calculatedWatermaks = this._calculateWatermaks();\n\n    this._lowRecordWatermark = calculatedWatermaks.low;\n    this._highRecordWatermark = calculatedWatermaks.high;\n    this._results = [];\n    this._bookmarkManager = bookmarkManager;\n    this._notificationFilter = notificationFilter;\n    this._log = log;\n  }\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   *\n   * @public\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @return {Result} New Result.\n   */\n\n\n  Session.prototype.run = function (query, parameters, transactionConfig) {\n    var _this = this;\n\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n        validatedQuery = _a.validatedQuery,\n        params = _a.params;\n\n    var autoCommitTxConfig = transactionConfig != null ? new tx_config_1.TxConfig(transactionConfig, this._log) : tx_config_1.TxConfig.empty();\n\n    var result = this._run(validatedQuery, params, function (connection) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var bookmarks;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this._bookmarks()];\n\n            case 1:\n              bookmarks = _a.sent();\n\n              this._assertSessionIsOpen();\n\n              return [2\n              /*return*/\n              , connection.run(validatedQuery, params, {\n                bookmarks: bookmarks,\n                txConfig: autoCommitTxConfig,\n                mode: this._mode,\n                database: this._database,\n                apiTelemetryConfig: {\n                  api: constants_1.TELEMETRY_APIS.AUTO_COMMIT_TRANSACTION\n                },\n                impersonatedUser: this._impersonatedUser,\n                afterComplete: function (meta) {\n                  return _this._onCompleteCallback(meta, bookmarks);\n                },\n                reactive: this._reactive,\n                fetchSize: this._fetchSize,\n                lowRecordWatermark: this._lowRecordWatermark,\n                highRecordWatermark: this._highRecordWatermark,\n                notificationFilter: this._notificationFilter\n              })];\n          }\n        });\n      });\n    });\n\n    this._results.push(result);\n\n    return result;\n  };\n\n  Session.prototype._run = function (query, parameters, customRunner) {\n    var _a = this._acquireAndConsumeConnection(customRunner),\n        connectionHolder = _a.connectionHolder,\n        resultPromise = _a.resultPromise;\n\n    var observerPromise = resultPromise.catch(function (error) {\n      return Promise.resolve(new observers_1.FailedObserver({\n        error: error\n      }));\n    });\n    var watermarks = {\n      high: this._highRecordWatermark,\n      low: this._lowRecordWatermark\n    };\n    return new result_1.default(observerPromise, query, parameters, connectionHolder, watermarks);\n  };\n  /**\n   * This method is used by Rediscovery on the neo4j-driver-bolt-protocol package.\n   *\n   * @private\n   * @param {function()} connectionConsumer The method which will use the connection\n   * @returns {Promise<T>} A connection promise\n   */\n\n\n  Session.prototype._acquireConnection = function (connectionConsumer) {\n    var _this = this;\n\n    var _a = this._acquireAndConsumeConnection(connectionConsumer),\n        connectionHolder = _a.connectionHolder,\n        resultPromise = _a.resultPromise;\n\n    return resultPromise.then(function (result) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , connectionHolder.releaseConnection()];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              , result];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Acquires a {@link Connection}, consume it and return a promise of the result along with\n   * the {@link ConnectionHolder} used in the process.\n   *\n   * @private\n   * @param connectionConsumer\n   * @returns {object} The connection holder and connection promise.\n   */\n\n\n  Session.prototype._acquireAndConsumeConnection = function (connectionConsumer) {\n    var resultPromise;\n\n    var connectionHolder = this._connectionHolderWithMode(this._mode);\n\n    if (!this._open) {\n      resultPromise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n    } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n      resultPromise = connectionHolder.getConnection() // Connection won't be null at this point since the initialize method\n      // return\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      .then(function (connection) {\n        return connectionConsumer(connection);\n      });\n    } else {\n      resultPromise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.'));\n    }\n\n    return {\n      connectionHolder: connectionHolder,\n      resultPromise: resultPromise\n    };\n  };\n  /**\n   * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n   * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n   *\n   * While a transaction is open the session cannot be used to run queries outside the transaction.\n   *\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @returns {TransactionPromise} New Transaction.\n   */\n\n\n  Session.prototype.beginTransaction = function (transactionConfig) {\n    // this function needs to support bookmarks parameter for backwards compatibility\n    // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n    // that's why we need to check parameter type and decide how to interpret the value\n    var arg = transactionConfig;\n    var txConfig = tx_config_1.TxConfig.empty();\n\n    if (arg != null) {\n      txConfig = new tx_config_1.TxConfig(arg, this._log);\n    }\n\n    return this._beginTransaction(this._mode, txConfig, {\n      api: constants_1.TELEMETRY_APIS.UNMANAGED_TRANSACTION\n    });\n  };\n\n  Session.prototype._beginTransaction = function (accessMode, txConfig, apiTelemetryConfig) {\n    var _this = this;\n\n    if (!this._open) {\n      throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n    }\n\n    if (this._hasTx) {\n      throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n    }\n\n    var mode = Session._validateSessionMode(accessMode);\n\n    var connectionHolder = this._connectionHolderWithMode(mode);\n\n    connectionHolder.initializeConnection();\n    this._hasTx = true;\n    var tx = new transaction_promise_1.default({\n      connectionHolder: connectionHolder,\n      impersonatedUser: this._impersonatedUser,\n      onClose: this._transactionClosed.bind(this),\n      onBookmarks: function (newBm, oldBm, db) {\n        return _this._updateBookmarks(newBm, oldBm, db);\n      },\n      onConnection: this._assertSessionIsOpen.bind(this),\n      reactive: this._reactive,\n      fetchSize: this._fetchSize,\n      lowRecordWatermark: this._lowRecordWatermark,\n      highRecordWatermark: this._highRecordWatermark,\n      notificationFilter: this._notificationFilter,\n      apiTelemetryConfig: apiTelemetryConfig\n    });\n\n    tx._begin(function () {\n      return _this._bookmarks();\n    }, txConfig);\n\n    return tx;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  Session.prototype._assertSessionIsOpen = function () {\n    if (!this._open) {\n      throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n    }\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  Session.prototype._transactionClosed = function () {\n    this._hasTx = false;\n  };\n  /**\n   * Return the bookmarks received following the last completed {@link Transaction}.\n   *\n   * @deprecated This method will be removed in version 6.0. Please, use Session#lastBookmarks instead.\n   *\n   * @return {string[]} A reference to a previous transaction.\n   * @see {@link Session#lastBookmarks}\n   */\n\n\n  Session.prototype.lastBookmark = function () {\n    return this.lastBookmarks();\n  };\n  /**\n   * Return the bookmarks received following the last completed {@link Transaction}.\n   *\n   * @return {string[]} A reference to a previous transaction.\n   */\n\n\n  Session.prototype.lastBookmarks = function () {\n    return this._lastBookmarks.values();\n  };\n\n  Session.prototype._bookmarks = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var bookmarks;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks()];\n\n          case 1:\n            bookmarks = _b.sent();\n\n            if (bookmarks === undefined) {\n              return [2\n              /*return*/\n              , this._lastBookmarks];\n            }\n\n            return [2\n            /*return*/\n            , new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(bookmarks), false), __read(this._configuredBookmarks), false))];\n        }\n      });\n    });\n  };\n  /**\n   * Execute given unit of work in a {@link READ} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @deprecated This method will be removed in version 6.0. Please, use Session#executeRead instead.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   * @see {@link Session#executeRead}\n   */\n\n\n  Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link WRITE} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @deprecated This method will be removed in version 6.0. Please, use Session#executeWrite instead.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   * @see {@link Session#executeWrite}\n   */\n\n\n  Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n\n  Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n\n    return this._transactionExecutor.execute(function (apiTelemetryConfig) {\n      return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig);\n    }, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link READ} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n\n\n  Session.prototype.executeRead = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._executeInTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link WRITE} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n\n\n  Session.prototype.executeWrite = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._executeInTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n  /**\n   * @private\n   * @param {SessionMode} accessMode\n   * @param {TxConfig} transactionConfig\n   * @param {ManagedTransactionWork} transactionWork\n   * @returns {Promise}\n   */\n\n\n  Session.prototype._executeInTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n\n    return this._transactionExecutor.execute(function (apiTelemetryConfig) {\n      return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig);\n    }, transactionWork, transaction_managed_1.default.fromTransaction);\n  };\n  /**\n   * Sets the resolved database name in the session context.\n   * @private\n   * @param {string|undefined} database The resolved database name\n   * @returns {void}\n   */\n\n\n  Session.prototype._onDatabaseNameResolved = function (database) {\n    if (!this._databaseNameResolved) {\n      var normalizedDatabase = database !== null && database !== void 0 ? database : '';\n      this._database = normalizedDatabase;\n\n      this._readConnectionHolder.setDatabase(normalizedDatabase);\n\n      this._writeConnectionHolder.setDatabase(normalizedDatabase);\n\n      this._databaseNameResolved = true;\n    }\n  };\n\n  Session.prototype._getConnectionAcquistionBookmarks = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var bookmarks;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks()];\n\n          case 1:\n            bookmarks = _b.sent();\n\n            if (bookmarks === undefined) {\n              return [2\n              /*return*/\n              , this._lastBookmarks];\n            }\n\n            return [2\n            /*return*/\n            , new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(this._configuredBookmarks), false), __read(bookmarks), false))];\n        }\n      });\n    });\n  };\n  /**\n   * Update value of the last bookmarks.\n   * @private\n   * @param {Bookmarks} newBookmarks - The new bookmarks.\n   * @returns {void}\n   */\n\n\n  Session.prototype._updateBookmarks = function (newBookmarks, previousBookmarks, database) {\n    var _a, _b, _c;\n\n    if (newBookmarks != null && !newBookmarks.isEmpty()) {\n      (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.updateBookmarks((_b = previousBookmarks === null || previousBookmarks === void 0 ? void 0 : previousBookmarks.values()) !== null && _b !== void 0 ? _b : [], (_c = newBookmarks === null || newBookmarks === void 0 ? void 0 : newBookmarks.values()) !== null && _c !== void 0 ? _c : []).catch(function () {});\n      this._lastBookmarks = newBookmarks;\n      this._configuredBookmarks = bookmarks_1.Bookmarks.empty();\n    }\n  };\n  /**\n   * Close this session.\n   * @return {Promise}\n   */\n\n\n  Session.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._open) return [3\n            /*break*/\n            , 3];\n            this._open = false;\n\n            this._results.forEach(function (result) {\n              return result._cancel();\n            });\n\n            this._transactionExecutor.close();\n\n            return [4\n            /*yield*/\n            , this._readConnectionHolder.close(this._hasTx)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._writeConnectionHolder.close(this._hasTx)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // eslint-disable-next-line\n  // @ts-ignore\n\n\n  Session.prototype[Symbol.asyncDispose] = function () {\n    return this.close();\n  };\n\n  Session.prototype._connectionHolderWithMode = function (mode) {\n    if (mode === constants_1.ACCESS_MODE_READ) {\n      return this._readConnectionHolder;\n    } else if (mode === constants_1.ACCESS_MODE_WRITE) {\n      return this._writeConnectionHolder;\n    } else {\n      throw (0, error_1.newError)('Unknown access mode: ' + mode);\n    }\n  };\n  /**\n   * @private\n   * @param {Object} meta Connection metadatada\n   * @returns {void}\n   */\n\n\n  Session.prototype._onCompleteCallback = function (meta, previousBookmarks) {\n    this._updateBookmarks(new bookmarks_1.Bookmarks(meta.bookmark), previousBookmarks, meta.db);\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  Session.prototype._calculateWatermaks = function () {\n    if (this._fetchSize === constants_1.FETCH_ALL) {\n      return {\n        low: Number.MAX_VALUE,\n        high: Number.MAX_VALUE // we shall never reach this number to disable auto pull\n\n      };\n    }\n\n    return {\n      low: 0.3 * this._fetchSize,\n      high: 0.7 * this._fetchSize\n    };\n  };\n  /**\n   * Configure the transaction executor\n   *\n   * This used by {@link Driver#executeQuery}\n   * @private\n   * @returns {void}\n   */\n\n\n  Session.prototype._configureTransactionExecutor = function (pipelined, telemetryApi) {\n    this._transactionExecutor.pipelineBegin = pipelined;\n    this._transactionExecutor.telemetryApi = telemetryApi;\n  };\n  /**\n   * @protected\n   */\n\n\n  Session._validateSessionMode = function (rawMode) {\n    var mode = rawMode !== null && rawMode !== void 0 ? rawMode : constants_1.ACCESS_MODE_WRITE;\n\n    if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n      throw (0, error_1.newError)('Illegal session mode ' + mode);\n    }\n\n    return mode;\n  };\n\n  return Session;\n}();\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\n\n\nfunction _createTransactionExecutor(config) {\n  var _a;\n\n  var maxRetryTimeMs = (_a = config === null || config === void 0 ? void 0 : config.maxTransactionRetryTime) !== null && _a !== void 0 ? _a : null;\n  return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\n\nexports.default = Session;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__read","o","m","i","r","ar","error","__spreadArray","to","from","pack","arguments","l","Array","prototype","slice","concat","__importDefault","mod","__esModule","Object","defineProperty","exports","observers_1","require","util_1","constants_1","error_1","result_1","connection_holder_1","transaction_executor_1","bookmarks_1","tx_config_1","transaction_promise_1","transaction_managed_1","Session","_a","mode","connectionProvider","bookmarks","database","config","reactive","fetchSize","impersonatedUser","bookmarkManager","notificationFilter","auth","log","_mode","_database","_reactive","_fetchSize","_onDatabaseNameResolved","bind","_getConnectionAcquistionBookmarks","_readConnectionHolder","ConnectionHolder","ACCESS_MODE_READ","onDatabaseNameResolved","getConnectionAcquistionBookmarks","_writeConnectionHolder","ACCESS_MODE_WRITE","_open","_hasTx","_impersonatedUser","_lastBookmarks","Bookmarks","empty","_configuredBookmarks","_transactionExecutor","_createTransactionExecutor","_databaseNameResolved","calculatedWatermaks","_calculateWatermaks","_lowRecordWatermark","low","_highRecordWatermark","high","_results","_bookmarkManager","_notificationFilter","_log","run","query","parameters","transactionConfig","_this","validateQueryAndParameters","validatedQuery","params","autoCommitTxConfig","TxConfig","_run","connection","_bookmarks","_assertSessionIsOpen","txConfig","apiTelemetryConfig","api","TELEMETRY_APIS","AUTO_COMMIT_TRANSACTION","afterComplete","meta","_onCompleteCallback","lowRecordWatermark","highRecordWatermark","customRunner","_acquireAndConsumeConnection","connectionHolder","resultPromise","observerPromise","catch","FailedObserver","watermarks","default","_acquireConnection","connectionConsumer","releaseConnection","_connectionHolderWithMode","newError","initializeConnection","getConnection","beginTransaction","arg","_beginTransaction","UNMANAGED_TRANSACTION","accessMode","_validateSessionMode","tx","onClose","_transactionClosed","onBookmarks","newBm","oldBm","db","_updateBookmarks","onConnection","_begin","lastBookmark","lastBookmarks","values","_b","getBookmarks","undefined","readTransaction","transactionWork","_runTransaction","writeTransaction","execute","executeRead","_executeInTransaction","executeWrite","fromTransaction","normalizedDatabase","setDatabase","newBookmarks","previousBookmarks","_c","isEmpty","updateBookmarks","close","forEach","_cancel","asyncDispose","bookmark","FETCH_ALL","Number","MAX_VALUE","_configureTransactionExecutor","pipelined","telemetryApi","pipelineBegin","rawMode","maxRetryTimeMs","maxTransactionRetryTime","TransactionExecutor"],"sources":["C:/projects/levelUp_v1/Level-Up-FN/Level-Up-Fronten-master/node_modules/neo4j-driver-core/lib/session.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar observers_1 = require(\"./internal/observers\");\nvar util_1 = require(\"./internal/util\");\nvar constants_1 = require(\"./internal/constants\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\nvar bookmarks_1 = require(\"./internal/bookmarks\");\nvar tx_config_1 = require(\"./internal/tx-config\");\nvar transaction_promise_1 = __importDefault(require(\"./transaction-promise\"));\nvar transaction_managed_1 = __importDefault(require(\"./transaction-managed\"));\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Object} args\n     * @param {string} args.mode the default access mode for this session.\n     * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n     * @param {Bookmarks} args.bookmarks - The initial bookmarks for this session.\n     * @param {string} args.database the database name\n     * @param {Object} args.config={} - This driver configuration.\n     * @param {boolean} args.reactive - Whether this session should create reactive streams\n     * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n     * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n     * @param {AuthToken} args.auth - the target auth for the to-be-acquired connection\n     * @param {NotificationFilter} args.notificationFilter - The notification filter used for this session.\n     */\n    function Session(_a) {\n        var mode = _a.mode, connectionProvider = _a.connectionProvider, bookmarks = _a.bookmarks, database = _a.database, config = _a.config, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser, bookmarkManager = _a.bookmarkManager, notificationFilter = _a.notificationFilter, auth = _a.auth, log = _a.log;\n        this._mode = mode;\n        this._database = database;\n        this._reactive = reactive;\n        this._fetchSize = fetchSize;\n        this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\n        this._getConnectionAcquistionBookmarks = this._getConnectionAcquistionBookmarks.bind(this);\n        this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_READ,\n            auth: auth,\n            database: database,\n            bookmarks: bookmarks,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved,\n            getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n            log: log\n        });\n        this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_WRITE,\n            auth: auth,\n            database: database,\n            bookmarks: bookmarks,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved,\n            getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n            log: log\n        });\n        this._open = true;\n        this._hasTx = false;\n        this._impersonatedUser = impersonatedUser;\n        this._lastBookmarks = bookmarks !== null && bookmarks !== void 0 ? bookmarks : bookmarks_1.Bookmarks.empty();\n        this._configuredBookmarks = this._lastBookmarks;\n        this._transactionExecutor = _createTransactionExecutor(config);\n        this._databaseNameResolved = this._database !== '';\n        var calculatedWatermaks = this._calculateWatermaks();\n        this._lowRecordWatermark = calculatedWatermaks.low;\n        this._highRecordWatermark = calculatedWatermaks.high;\n        this._results = [];\n        this._bookmarkManager = bookmarkManager;\n        this._notificationFilter = notificationFilter;\n        this._log = log;\n    }\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     *\n     * @public\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @return {Result} New Result.\n     */\n    Session.prototype.run = function (query, parameters, transactionConfig) {\n        var _this = this;\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var autoCommitTxConfig = (transactionConfig != null)\n            ? new tx_config_1.TxConfig(transactionConfig, this._log)\n            : tx_config_1.TxConfig.empty();\n        var result = this._run(validatedQuery, params, function (connection) { return __awaiter(_this, void 0, void 0, function () {\n            var bookmarks;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._bookmarks()];\n                    case 1:\n                        bookmarks = _a.sent();\n                        this._assertSessionIsOpen();\n                        return [2 /*return*/, connection.run(validatedQuery, params, {\n                                bookmarks: bookmarks,\n                                txConfig: autoCommitTxConfig,\n                                mode: this._mode,\n                                database: this._database,\n                                apiTelemetryConfig: {\n                                    api: constants_1.TELEMETRY_APIS.AUTO_COMMIT_TRANSACTION\n                                },\n                                impersonatedUser: this._impersonatedUser,\n                                afterComplete: function (meta) { return _this._onCompleteCallback(meta, bookmarks); },\n                                reactive: this._reactive,\n                                fetchSize: this._fetchSize,\n                                lowRecordWatermark: this._lowRecordWatermark,\n                                highRecordWatermark: this._highRecordWatermark,\n                                notificationFilter: this._notificationFilter\n                            })];\n                }\n            });\n        }); });\n        this._results.push(result);\n        return result;\n    };\n    Session.prototype._run = function (query, parameters, customRunner) {\n        var _a = this._acquireAndConsumeConnection(customRunner), connectionHolder = _a.connectionHolder, resultPromise = _a.resultPromise;\n        var observerPromise = resultPromise.catch(function (error) { return Promise.resolve(new observers_1.FailedObserver({ error: error })); });\n        var watermarks = { high: this._highRecordWatermark, low: this._lowRecordWatermark };\n        return new result_1.default(observerPromise, query, parameters, connectionHolder, watermarks);\n    };\n    /**\n     * This method is used by Rediscovery on the neo4j-driver-bolt-protocol package.\n     *\n     * @private\n     * @param {function()} connectionConsumer The method which will use the connection\n     * @returns {Promise<T>} A connection promise\n     */\n    Session.prototype._acquireConnection = function (connectionConsumer) {\n        var _this = this;\n        var _a = this._acquireAndConsumeConnection(connectionConsumer), connectionHolder = _a.connectionHolder, resultPromise = _a.resultPromise;\n        return resultPromise.then(function (result) { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, connectionHolder.releaseConnection()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, result];\n                }\n            });\n        }); });\n    };\n    /**\n     * Acquires a {@link Connection}, consume it and return a promise of the result along with\n     * the {@link ConnectionHolder} used in the process.\n     *\n     * @private\n     * @param connectionConsumer\n     * @returns {object} The connection holder and connection promise.\n     */\n    Session.prototype._acquireAndConsumeConnection = function (connectionConsumer) {\n        var resultPromise;\n        var connectionHolder = this._connectionHolderWithMode(this._mode);\n        if (!this._open) {\n            resultPromise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n        }\n        else if (!this._hasTx && connectionHolder.initializeConnection()) {\n            resultPromise = connectionHolder\n                .getConnection()\n                // Connection won't be null at this point since the initialize method\n                // return\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                .then(function (connection) { return connectionConsumer(connection); });\n        }\n        else {\n            resultPromise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' +\n                'session with an open transaction; either run from within the ' +\n                'transaction or use a different session.'));\n        }\n        return { connectionHolder: connectionHolder, resultPromise: resultPromise };\n    };\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @returns {TransactionPromise} New Transaction.\n     */\n    Session.prototype.beginTransaction = function (transactionConfig) {\n        // this function needs to support bookmarks parameter for backwards compatibility\n        // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n        // that's why we need to check parameter type and decide how to interpret the value\n        var arg = transactionConfig;\n        var txConfig = tx_config_1.TxConfig.empty();\n        if (arg != null) {\n            txConfig = new tx_config_1.TxConfig(arg, this._log);\n        }\n        return this._beginTransaction(this._mode, txConfig, { api: constants_1.TELEMETRY_APIS.UNMANAGED_TRANSACTION });\n    };\n    Session.prototype._beginTransaction = function (accessMode, txConfig, apiTelemetryConfig) {\n        var _this = this;\n        if (!this._open) {\n            throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n        }\n        if (this._hasTx) {\n            throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' +\n                'either run from within the transaction or use a different session.');\n        }\n        var mode = Session._validateSessionMode(accessMode);\n        var connectionHolder = this._connectionHolderWithMode(mode);\n        connectionHolder.initializeConnection();\n        this._hasTx = true;\n        var tx = new transaction_promise_1.default({\n            connectionHolder: connectionHolder,\n            impersonatedUser: this._impersonatedUser,\n            onClose: this._transactionClosed.bind(this),\n            onBookmarks: function (newBm, oldBm, db) { return _this._updateBookmarks(newBm, oldBm, db); },\n            onConnection: this._assertSessionIsOpen.bind(this),\n            reactive: this._reactive,\n            fetchSize: this._fetchSize,\n            lowRecordWatermark: this._lowRecordWatermark,\n            highRecordWatermark: this._highRecordWatermark,\n            notificationFilter: this._notificationFilter,\n            apiTelemetryConfig: apiTelemetryConfig\n        });\n        tx._begin(function () { return _this._bookmarks(); }, txConfig);\n        return tx;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._assertSessionIsOpen = function () {\n        if (!this._open) {\n            throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._transactionClosed = function () {\n        this._hasTx = false;\n    };\n    /**\n     * Return the bookmarks received following the last completed {@link Transaction}.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use Session#lastBookmarks instead.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     * @see {@link Session#lastBookmarks}\n     */\n    Session.prototype.lastBookmark = function () {\n        return this.lastBookmarks();\n    };\n    /**\n     * Return the bookmarks received following the last completed {@link Transaction}.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     */\n    Session.prototype.lastBookmarks = function () {\n        return this._lastBookmarks.values();\n    };\n    Session.prototype._bookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, ((_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks())];\n                    case 1:\n                        bookmarks = _b.sent();\n                        if (bookmarks === undefined) {\n                            return [2 /*return*/, this._lastBookmarks];\n                        }\n                        return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(bookmarks), false), __read(this._configuredBookmarks), false))];\n                }\n            });\n        });\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use Session#executeRead instead.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     * @see {@link Session#executeRead}\n     */\n    Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use Session#executeWrite instead.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     * @see {@link Session#executeWrite}\n     */\n    Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function (apiTelemetryConfig) { return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig); }, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.executeRead = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._executeInTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.executeWrite = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._executeInTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    /**\n     * @private\n     * @param {SessionMode} accessMode\n     * @param {TxConfig} transactionConfig\n     * @param {ManagedTransactionWork} transactionWork\n     * @returns {Promise}\n     */\n    Session.prototype._executeInTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function (apiTelemetryConfig) { return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig); }, transactionWork, transaction_managed_1.default.fromTransaction);\n    };\n    /**\n     * Sets the resolved database name in the session context.\n     * @private\n     * @param {string|undefined} database The resolved database name\n     * @returns {void}\n     */\n    Session.prototype._onDatabaseNameResolved = function (database) {\n        if (!this._databaseNameResolved) {\n            var normalizedDatabase = database !== null && database !== void 0 ? database : '';\n            this._database = normalizedDatabase;\n            this._readConnectionHolder.setDatabase(normalizedDatabase);\n            this._writeConnectionHolder.setDatabase(normalizedDatabase);\n            this._databaseNameResolved = true;\n        }\n    };\n    Session.prototype._getConnectionAcquistionBookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, ((_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks())];\n                    case 1:\n                        bookmarks = _b.sent();\n                        if (bookmarks === undefined) {\n                            return [2 /*return*/, this._lastBookmarks];\n                        }\n                        return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(this._configuredBookmarks), false), __read(bookmarks), false))];\n                }\n            });\n        });\n    };\n    /**\n     * Update value of the last bookmarks.\n     * @private\n     * @param {Bookmarks} newBookmarks - The new bookmarks.\n     * @returns {void}\n     */\n    Session.prototype._updateBookmarks = function (newBookmarks, previousBookmarks, database) {\n        var _a, _b, _c;\n        if ((newBookmarks != null) && !newBookmarks.isEmpty()) {\n            (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.updateBookmarks((_b = previousBookmarks === null || previousBookmarks === void 0 ? void 0 : previousBookmarks.values()) !== null && _b !== void 0 ? _b : [], (_c = newBookmarks === null || newBookmarks === void 0 ? void 0 : newBookmarks.values()) !== null && _c !== void 0 ? _c : []).catch(function () { });\n            this._lastBookmarks = newBookmarks;\n            this._configuredBookmarks = bookmarks_1.Bookmarks.empty();\n        }\n    };\n    /**\n     * Close this session.\n     * @return {Promise}\n     */\n    Session.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._open) return [3 /*break*/, 3];\n                        this._open = false;\n                        this._results.forEach(function (result) { return result._cancel(); });\n                        this._transactionExecutor.close();\n                        return [4 /*yield*/, this._readConnectionHolder.close(this._hasTx)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this._writeConnectionHolder.close(this._hasTx)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // eslint-disable-next-line\n    // @ts-ignore\n    Session.prototype[Symbol.asyncDispose] = function () {\n        return this.close();\n    };\n    Session.prototype._connectionHolderWithMode = function (mode) {\n        if (mode === constants_1.ACCESS_MODE_READ) {\n            return this._readConnectionHolder;\n        }\n        else if (mode === constants_1.ACCESS_MODE_WRITE) {\n            return this._writeConnectionHolder;\n        }\n        else {\n            throw (0, error_1.newError)('Unknown access mode: ' + mode);\n        }\n    };\n    /**\n     * @private\n     * @param {Object} meta Connection metadatada\n     * @returns {void}\n     */\n    Session.prototype._onCompleteCallback = function (meta, previousBookmarks) {\n        this._updateBookmarks(new bookmarks_1.Bookmarks(meta.bookmark), previousBookmarks, meta.db);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._calculateWatermaks = function () {\n        if (this._fetchSize === constants_1.FETCH_ALL) {\n            return {\n                low: Number.MAX_VALUE,\n                high: Number.MAX_VALUE // we shall never reach this number to disable auto pull\n            };\n        }\n        return {\n            low: 0.3 * this._fetchSize,\n            high: 0.7 * this._fetchSize\n        };\n    };\n    /**\n     * Configure the transaction executor\n     *\n     * This used by {@link Driver#executeQuery}\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._configureTransactionExecutor = function (pipelined, telemetryApi) {\n        this._transactionExecutor.pipelineBegin = pipelined;\n        this._transactionExecutor.telemetryApi = telemetryApi;\n    };\n    /**\n     * @protected\n     */\n    Session._validateSessionMode = function (rawMode) {\n        var mode = rawMode !== null && rawMode !== void 0 ? rawMode : constants_1.ACCESS_MODE_WRITE;\n        if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n            throw (0, error_1.newError)('Illegal session mode ' + mode);\n        }\n        return mode;\n    };\n    return Session;\n}());\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\nfunction _createTransactionExecutor(config) {\n    var _a;\n    var maxRetryTimeMs = (_a = config === null || config === void 0 ? void 0 : config.maxTransactionRetryTime) !== null && _a !== void 0 ? _a : null;\n    return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\nexports.default = Session;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}