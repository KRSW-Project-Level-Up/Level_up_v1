{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeTransformer = void 0;\n\nvar packstream_1 = require(\"../packstream\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar objectUtil = neo4j_driver_core_1.internal.objectUtil;\n/**\n * Class responsible for applying the expected {@link TypeTransformer} to\n * transform the driver types from and to {@link struct.Structure}\n */\n\nvar Transformer =\n/** @class */\nfunction () {\n  /**\n   * Constructor\n   * @param {TypeTransformer[]} transformers The type transformers\n   */\n  function Transformer(transformers) {\n    this._transformers = transformers;\n    this._transformersPerSignature = new Map(transformers.map(function (typeTransformer) {\n      return [typeTransformer.signature, typeTransformer];\n    }));\n    this.fromStructure = this.fromStructure.bind(this);\n    this.toStructure = this.toStructure.bind(this);\n    Object.freeze(this);\n  }\n  /**\n   * Transform from structure to specific object\n   *\n   * @param {struct.Structure} struct The structure\n   * @returns {<T>|structure.Structure} The driver object or the structure if the transformer was not found.\n   */\n\n\n  Transformer.prototype.fromStructure = function (struct) {\n    try {\n      if (struct instanceof packstream_1.structure.Structure && this._transformersPerSignature.has(struct.signature)) {\n        var fromStructure = this._transformersPerSignature.get(struct.signature).fromStructure;\n\n        return fromStructure(struct);\n      }\n\n      return struct;\n    } catch (error) {\n      return objectUtil.createBrokenObject(error);\n    }\n  };\n  /**\n   * Transform from object to structure\n   * @param {<T>} type The object to be transoformed in structure\n   * @returns {<T>|structure.Structure} The structure or the object, if any transformer was found\n   */\n\n\n  Transformer.prototype.toStructure = function (type) {\n    var transformer = this._transformers.find(function (_a) {\n      var isTypeInstance = _a.isTypeInstance;\n      return isTypeInstance(type);\n    });\n\n    if (transformer !== undefined) {\n      return transformer.toStructure(type);\n    }\n\n    return type;\n  };\n\n  return Transformer;\n}();\n\nexports.default = Transformer;\n/**\n * @callback isTypeInstanceFunction\n * @param {any} object The object\n * @return {boolean} is instance of\n */\n\n/**\n * @callback toStructureFunction\n * @param {any} object The object\n * @return {structure.Structure} The structure\n */\n\n/**\n * @callback fromStructureFunction\n * @param {structure.Structure} struct The structure\n * @return {any} The object\n */\n\n/**\n * Class responsible for grouping the properties of a TypeTransformer\n */\n\nvar TypeTransformer =\n/** @class */\nfunction () {\n  /**\n   * @param {Object} param\n   * @param {number} param.signature The signature of the structure\n   * @param {isTypeInstanceFunction} param.isTypeInstance The function which checks if object is\n   *                instance of the type described by the TypeTransformer\n   * @param {toStructureFunction} param.toStructure The function which gets the object and converts to structure\n   * @param {fromStructureFunction} param.fromStructure The function which get the structure and covnverts to object\n   */\n  function TypeTransformer(_a) {\n    var signature = _a.signature,\n        fromStructure = _a.fromStructure,\n        toStructure = _a.toStructure,\n        isTypeInstance = _a.isTypeInstance;\n    this.signature = signature;\n    this.isTypeInstance = isTypeInstance;\n    this.fromStructure = fromStructure;\n    this.toStructure = toStructure;\n    Object.freeze(this);\n  }\n  /**\n   * @param {Object} param\n   * @param {number} [param.signature] The signature of the structure\n   * @param {isTypeInstanceFunction} [param.isTypeInstance] The function which checks if object is\n   *                instance of the type described by the TypeTransformer\n   * @param {toStructureFunction} [param.toStructure] The function which gets the object and converts to structure\n   * @param {fromStructureFunction} pparam.fromStructure] The function which get the structure and covnverts to object\n   * @returns {TypeTransformer} A new type transform extends with new methods\n   */\n\n\n  TypeTransformer.prototype.extendsWith = function (_a) {\n    var signature = _a.signature,\n        fromStructure = _a.fromStructure,\n        toStructure = _a.toStructure,\n        isTypeInstance = _a.isTypeInstance;\n    return new TypeTransformer({\n      signature: signature || this.signature,\n      fromStructure: fromStructure || this.fromStructure,\n      toStructure: toStructure || this.toStructure,\n      isTypeInstance: isTypeInstance || this.isTypeInstance\n    });\n  };\n\n  return TypeTransformer;\n}();\n\nexports.TypeTransformer = TypeTransformer;","map":{"version":3,"names":["Object","defineProperty","exports","value","TypeTransformer","packstream_1","require","neo4j_driver_core_1","objectUtil","internal","Transformer","transformers","_transformers","_transformersPerSignature","Map","map","typeTransformer","signature","fromStructure","bind","toStructure","freeze","prototype","struct","structure","Structure","has","get","error","createBrokenObject","type","transformer","find","_a","isTypeInstance","undefined","default","extendsWith"],"sources":["C:/projects/levelUp_v1/Level-Up-FN/Level-Up-Fronten-master/node_modules/neo4j-driver-bolt-connection/lib/bolt/transformer.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeTransformer = void 0;\nvar packstream_1 = require(\"../packstream\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar objectUtil = neo4j_driver_core_1.internal.objectUtil;\n/**\n * Class responsible for applying the expected {@link TypeTransformer} to\n * transform the driver types from and to {@link struct.Structure}\n */\nvar Transformer = /** @class */ (function () {\n    /**\n     * Constructor\n     * @param {TypeTransformer[]} transformers The type transformers\n     */\n    function Transformer(transformers) {\n        this._transformers = transformers;\n        this._transformersPerSignature = new Map(transformers.map(function (typeTransformer) { return [typeTransformer.signature, typeTransformer]; }));\n        this.fromStructure = this.fromStructure.bind(this);\n        this.toStructure = this.toStructure.bind(this);\n        Object.freeze(this);\n    }\n    /**\n     * Transform from structure to specific object\n     *\n     * @param {struct.Structure} struct The structure\n     * @returns {<T>|structure.Structure} The driver object or the structure if the transformer was not found.\n     */\n    Transformer.prototype.fromStructure = function (struct) {\n        try {\n            if (struct instanceof packstream_1.structure.Structure && this._transformersPerSignature.has(struct.signature)) {\n                var fromStructure = this._transformersPerSignature.get(struct.signature).fromStructure;\n                return fromStructure(struct);\n            }\n            return struct;\n        }\n        catch (error) {\n            return objectUtil.createBrokenObject(error);\n        }\n    };\n    /**\n     * Transform from object to structure\n     * @param {<T>} type The object to be transoformed in structure\n     * @returns {<T>|structure.Structure} The structure or the object, if any transformer was found\n     */\n    Transformer.prototype.toStructure = function (type) {\n        var transformer = this._transformers.find(function (_a) {\n            var isTypeInstance = _a.isTypeInstance;\n            return isTypeInstance(type);\n        });\n        if (transformer !== undefined) {\n            return transformer.toStructure(type);\n        }\n        return type;\n    };\n    return Transformer;\n}());\nexports.default = Transformer;\n/**\n * @callback isTypeInstanceFunction\n * @param {any} object The object\n * @return {boolean} is instance of\n */\n/**\n * @callback toStructureFunction\n * @param {any} object The object\n * @return {structure.Structure} The structure\n */\n/**\n * @callback fromStructureFunction\n * @param {structure.Structure} struct The structure\n * @return {any} The object\n */\n/**\n * Class responsible for grouping the properties of a TypeTransformer\n */\nvar TypeTransformer = /** @class */ (function () {\n    /**\n     * @param {Object} param\n     * @param {number} param.signature The signature of the structure\n     * @param {isTypeInstanceFunction} param.isTypeInstance The function which checks if object is\n     *                instance of the type described by the TypeTransformer\n     * @param {toStructureFunction} param.toStructure The function which gets the object and converts to structure\n     * @param {fromStructureFunction} param.fromStructure The function which get the structure and covnverts to object\n     */\n    function TypeTransformer(_a) {\n        var signature = _a.signature, fromStructure = _a.fromStructure, toStructure = _a.toStructure, isTypeInstance = _a.isTypeInstance;\n        this.signature = signature;\n        this.isTypeInstance = isTypeInstance;\n        this.fromStructure = fromStructure;\n        this.toStructure = toStructure;\n        Object.freeze(this);\n    }\n    /**\n     * @param {Object} param\n     * @param {number} [param.signature] The signature of the structure\n     * @param {isTypeInstanceFunction} [param.isTypeInstance] The function which checks if object is\n     *                instance of the type described by the TypeTransformer\n     * @param {toStructureFunction} [param.toStructure] The function which gets the object and converts to structure\n     * @param {fromStructureFunction} pparam.fromStructure] The function which get the structure and covnverts to object\n     * @returns {TypeTransformer} A new type transform extends with new methods\n     */\n    TypeTransformer.prototype.extendsWith = function (_a) {\n        var signature = _a.signature, fromStructure = _a.fromStructure, toStructure = _a.toStructure, isTypeInstance = _a.isTypeInstance;\n        return new TypeTransformer({\n            signature: signature || this.signature,\n            fromStructure: fromStructure || this.fromStructure,\n            toStructure: toStructure || this.toStructure,\n            isTypeInstance: isTypeInstance || this.isTypeInstance\n        });\n    };\n    return TypeTransformer;\n}());\nexports.TypeTransformer = TypeTransformer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}