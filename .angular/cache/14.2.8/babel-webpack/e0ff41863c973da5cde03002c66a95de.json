{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\n\nvar json_1 = require(\"./json\");\n\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\n\nfunction hasIdentifierProperty(obj, property) {\n  return obj != null && obj[property] === true;\n}\n/**\n * Class for Node Type.\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {NumberOrInteger} identity - Unique identity\n   * @param {Array<string>} labels - Array for all labels\n   * @param {Properties} properties - Map with node properties\n   * @param {string} elementId - Node element identifier\n   */\n  function Node(identity, labels, properties, elementId) {\n    /**\n     * Identity of the node.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Node#elementId} instead\n     */\n    this.identity = identity;\n    /**\n     * Labels of the node.\n     * @type {string[]}\n     */\n\n    this.labels = labels;\n    /**\n     * Properties of the node.\n     * @type {Properties}\n     */\n\n    this.properties = properties;\n    /**\n     * The Node element identifier.\n     * @type {string}\n     */\n\n    this.elementId = _valueOrGetDefault(elementId, function () {\n      return identity.toString();\n    });\n  }\n  /**\n   * @ignore\n   */\n\n\n  Node.prototype.toString = function () {\n    var s = '(' + this.elementId;\n\n    for (var i = 0; i < this.labels.length; i++) {\n      s += ':' + this.labels[i];\n    }\n\n    var keys = Object.keys(this.properties);\n\n    if (keys.length > 0) {\n      s += ' {';\n\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n\n      s += '}';\n    }\n\n    s += ')';\n    return s;\n  };\n\n  return Node;\n}();\n\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\n\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\n\nexports.isNode = isNode;\n/**\n * Class for Relationship Type.\n */\n\nvar Relationship =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {NumberOrInteger} identity - Unique identity\n   * @param {NumberOrInteger} start - Identity of start Node\n   * @param {NumberOrInteger} end - Identity of end Node\n   * @param {string} type - Relationship type\n   * @param {Properties} properties - Map with relationship properties\n   * @param {string} elementId - Relationship element identifier\n   * @param {string} startNodeElementId - Start Node element identifier\n   * @param {string} endNodeElementId - End Node element identifier\n   */\n  function Relationship(identity, start, end, type, properties, elementId, startNodeElementId, endNodeElementId) {\n    /**\n     * Identity of the relationship.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Relationship#elementId} instead\n     */\n    this.identity = identity;\n    /**\n     * Identity of the start node.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Relationship#startNodeElementId} instead\n     */\n\n    this.start = start;\n    /**\n     * Identity of the end node.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Relationship#endNodeElementId} instead\n     */\n\n    this.end = end;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Properties}\n     */\n\n    this.properties = properties;\n    /**\n     * The Relationship element identifier.\n     * @type {string}\n     */\n\n    this.elementId = _valueOrGetDefault(elementId, function () {\n      return identity.toString();\n    });\n    /**\n     * The Start Node element identifier.\n     * @type {string}\n     */\n\n    this.startNodeElementId = _valueOrGetDefault(startNodeElementId, function () {\n      return start.toString();\n    });\n    /**\n     * The End Node element identifier.\n     * @type {string}\n     */\n\n    this.endNodeElementId = _valueOrGetDefault(endNodeElementId, function () {\n      return end.toString();\n    });\n  }\n  /**\n   * @ignore\n   */\n\n\n  Relationship.prototype.toString = function () {\n    var s = '(' + this.startNodeElementId + ')-[:' + this.type;\n    var keys = Object.keys(this.properties);\n\n    if (keys.length > 0) {\n      s += ' {';\n\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n\n      s += '}';\n    }\n\n    s += ']->(' + this.endNodeElementId + ')';\n    return s;\n  };\n\n  return Relationship;\n}();\n\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\n\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n\nexports.isRelationship = isRelationship;\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\n\nvar UnboundRelationship =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {NumberOrInteger} identity - Unique identity\n   * @param {string} type - Relationship type\n   * @param {Properties} properties - Map with relationship properties\n   * @param {string} elementId - Relationship element identifier\n   */\n  function UnboundRelationship(identity, type, properties, elementId) {\n    /**\n     * Identity of the relationship.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link UnboundRelationship#elementId} instead\n     */\n    this.identity = identity;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Properties}\n     */\n\n    this.properties = properties;\n    /**\n     * The Relationship element identifier.\n     * @type {string}\n     */\n\n    this.elementId = _valueOrGetDefault(elementId, function () {\n      return identity.toString();\n    });\n  }\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @deprecated use {@link UnboundRelationship#bindTo} instead\n   * @param {Integer} start - Identity of start node\n   * @param {Integer} end - Identity of end node\n   * @return {Relationship} - Created relationship\n   */\n\n\n  UnboundRelationship.prototype.bind = function (start, end) {\n    return new Relationship(this.identity, start, end, this.type, this.properties, this.elementId);\n  };\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @param {Node} start - Start Node\n   * @param {Node} end - End Node\n   * @return {Relationship} - Created relationship\n   */\n\n\n  UnboundRelationship.prototype.bindTo = function (start, end) {\n    return new Relationship(this.identity, start.identity, end.identity, this.type, this.properties, this.elementId, start.elementId, end.elementId);\n  };\n  /**\n   * @ignore\n   */\n\n\n  UnboundRelationship.prototype.toString = function () {\n    var s = '-[:' + this.type;\n    var keys = Object.keys(this.properties);\n\n    if (keys.length > 0) {\n      s += ' {';\n\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n\n      s += '}';\n    }\n\n    s += ']->';\n    return s;\n  };\n\n  return UnboundRelationship;\n}();\n\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n */\n\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\n * Class for PathSegment Type.\n */\n\nvar PathSegment =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Node} start - start node\n   * @param {Relationship} rel - relationship that connects start and end node\n   * @param {Node} end - end node\n   */\n  function PathSegment(start, rel, end) {\n    /**\n     * Start node.\n     * @type {Node}\n     */\n    this.start = start;\n    /**\n     * Relationship.\n     * @type {Relationship}\n     */\n\n    this.relationship = rel;\n    /**\n     * End node.\n     * @type {Node}\n     */\n\n    this.end = end;\n  }\n\n  return PathSegment;\n}();\n\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\n\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\n\nexports.isPathSegment = isPathSegment;\n/**\n * Class for Path Type.\n */\n\nvar Path =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Node} start  - start node\n   * @param {Node} end - end node\n   * @param {Array<PathSegment>} segments - Array of Segments\n   */\n  function Path(start, end, segments) {\n    /**\n     * Start node.\n     * @type {Node}\n     */\n    this.start = start;\n    /**\n     * End node.\n     * @type {Node}\n     */\n\n    this.end = end;\n    /**\n     * Segments.\n     * @type {Array<PathSegment>}\n     */\n\n    this.segments = segments;\n    /**\n     * Length of the segments.\n     * @type {Number}\n     */\n\n    this.length = segments.length;\n  }\n\n  return Path;\n}();\n\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\n\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\n\nexports.isPath = isPath;\n\nfunction _valueOrGetDefault(value, getDefault) {\n  return value === undefined || value === null ? getDefault() : value;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","isPathSegment","PathSegment","isPath","Path","isUnboundRelationship","UnboundRelationship","isRelationship","Relationship","isNode","Node","json_1","require","IDENTIFIER_PROPERTY_ATTRIBUTES","enumerable","configurable","writable","NODE_IDENTIFIER_PROPERTY","RELATIONSHIP_IDENTIFIER_PROPERTY","UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY","PATH_IDENTIFIER_PROPERTY","PATH_SEGMENT_IDENTIFIER_PROPERTY","hasIdentifierProperty","obj","property","identity","labels","properties","elementId","_valueOrGetDefault","toString","prototype","s","i","length","keys","stringify","start","end","type","startNodeElementId","endNodeElementId","bind","bindTo","rel","relationship","segments","getDefault","undefined"],"sources":["C:/projects/levelUp_v1/Level-Up-FN/Level-Up-Fronten-master/node_modules/neo4j-driver-core/lib/graph-types.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\nvar json_1 = require(\"./json\");\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n    value: true,\n    enumerable: false,\n    configurable: false,\n    writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\nfunction hasIdentifierProperty(obj, property) {\n    return obj != null && obj[property] === true;\n}\n/**\n * Class for Node Type.\n */\nvar Node = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {Array<string>} labels - Array for all labels\n     * @param {Properties} properties - Map with node properties\n     * @param {string} elementId - Node element identifier\n     */\n    function Node(identity, labels, properties, elementId) {\n        /**\n         * Identity of the node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Node#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Labels of the node.\n         * @type {string[]}\n         */\n        this.labels = labels;\n        /**\n         * Properties of the node.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Node element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n    }\n    /**\n     * @ignore\n     */\n    Node.prototype.toString = function () {\n        var s = '(' + this.elementId;\n        for (var i = 0; i < this.labels.length; i++) {\n            s += ':' + this.labels[i];\n        }\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ')';\n        return s;\n    };\n    return Node;\n}());\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\nfunction isNode(obj) {\n    return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\nexports.isNode = isNode;\n/**\n * Class for Relationship Type.\n */\nvar Relationship = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {NumberOrInteger} start - Identity of start Node\n     * @param {NumberOrInteger} end - Identity of end Node\n     * @param {string} type - Relationship type\n     * @param {Properties} properties - Map with relationship properties\n     * @param {string} elementId - Relationship element identifier\n     * @param {string} startNodeElementId - Start Node element identifier\n     * @param {string} endNodeElementId - End Node element identifier\n     */\n    function Relationship(identity, start, end, type, properties, elementId, startNodeElementId, endNodeElementId) {\n        /**\n         * Identity of the relationship.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Identity of the start node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#startNodeElementId} instead\n         */\n        this.start = start;\n        /**\n         * Identity of the end node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#endNodeElementId} instead\n         */\n        this.end = end;\n        /**\n         * Type of the relationship.\n         * @type {string}\n         */\n        this.type = type;\n        /**\n         * Properties of the relationship.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Relationship element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n        /**\n         * The Start Node element identifier.\n         * @type {string}\n         */\n        this.startNodeElementId = _valueOrGetDefault(startNodeElementId, function () { return start.toString(); });\n        /**\n         * The End Node element identifier.\n         * @type {string}\n         */\n        this.endNodeElementId = _valueOrGetDefault(endNodeElementId, function () { return end.toString(); });\n    }\n    /**\n     * @ignore\n     */\n    Relationship.prototype.toString = function () {\n        var s = '(' + this.startNodeElementId + ')-[:' + this.type;\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ']->(' + this.endNodeElementId + ')';\n        return s;\n    };\n    return Relationship;\n}());\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\nfunction isRelationship(obj) {\n    return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isRelationship = isRelationship;\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\nvar UnboundRelationship = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {string} type - Relationship type\n     * @param {Properties} properties - Map with relationship properties\n     * @param {string} elementId - Relationship element identifier\n     */\n    function UnboundRelationship(identity, type, properties, elementId) {\n        /**\n         * Identity of the relationship.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link UnboundRelationship#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Type of the relationship.\n         * @type {string}\n         */\n        this.type = type;\n        /**\n         * Properties of the relationship.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Relationship element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n    }\n    /**\n     * Bind relationship\n     *\n     * @protected\n     * @deprecated use {@link UnboundRelationship#bindTo} instead\n     * @param {Integer} start - Identity of start node\n     * @param {Integer} end - Identity of end node\n     * @return {Relationship} - Created relationship\n     */\n    UnboundRelationship.prototype.bind = function (start, end) {\n        return new Relationship(this.identity, start, end, this.type, this.properties, this.elementId);\n    };\n    /**\n     * Bind relationship\n     *\n     * @protected\n     * @param {Node} start - Start Node\n     * @param {Node} end - End Node\n     * @return {Relationship} - Created relationship\n     */\n    UnboundRelationship.prototype.bindTo = function (start, end) {\n        return new Relationship(this.identity, start.identity, end.identity, this.type, this.properties, this.elementId, start.elementId, end.elementId);\n    };\n    /**\n     * @ignore\n     */\n    UnboundRelationship.prototype.toString = function () {\n        var s = '-[:' + this.type;\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ']->';\n        return s;\n    };\n    return UnboundRelationship;\n}());\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n */\nfunction isUnboundRelationship(obj) {\n    return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\n * Class for PathSegment Type.\n */\nvar PathSegment = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Node} start - start node\n     * @param {Relationship} rel - relationship that connects start and end node\n     * @param {Node} end - end node\n     */\n    function PathSegment(start, rel, end) {\n        /**\n         * Start node.\n         * @type {Node}\n         */\n        this.start = start;\n        /**\n         * Relationship.\n         * @type {Relationship}\n         */\n        this.relationship = rel;\n        /**\n         * End node.\n         * @type {Node}\n         */\n        this.end = end;\n    }\n    return PathSegment;\n}());\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\nfunction isPathSegment(obj) {\n    return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\nexports.isPathSegment = isPathSegment;\n/**\n * Class for Path Type.\n */\nvar Path = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Node} start  - start node\n     * @param {Node} end - end node\n     * @param {Array<PathSegment>} segments - Array of Segments\n     */\n    function Path(start, end, segments) {\n        /**\n         * Start node.\n         * @type {Node}\n         */\n        this.start = start;\n        /**\n         * End node.\n         * @type {Node}\n         */\n        this.end = end;\n        /**\n         * Segments.\n         * @type {Array<PathSegment>}\n         */\n        this.segments = segments;\n        /**\n         * Length of the segments.\n         * @type {Number}\n         */\n        this.length = segments.length;\n    }\n    return Path;\n}());\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\nfunction isPath(obj) {\n    return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\nexports.isPath = isPath;\nfunction _valueOrGetDefault(value, getDefault) {\n    return value === undefined || value === null ? getDefault() : value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}